[{"title":"SpringBoot整合-通用Mapper","url":"/2020/04/03/SpringBoot整合-通用Mapper/","content":"\n## SpringBoot整合-通用Mapper\n\n**目标**：配置通用Mapper组件到SpringBoot项目中并使用Mapper<T>接口\n\n**分析**：\n\n通用Mapper：可以实现自动拼接sql语句；所有的Mapper都不需要编写任何方法也就是不用编写sql语句，可以提高开发效率。\n\n如果有特殊需要，可以通用Mapper官方查看：\n\n[]: https://github.com/abel533/Mapper/wiki/3.config\t\"Mapper官方链接\"\n\n1. 添加启动器依赖；\n2. 改造UserMapper继承Mapper<User>；\n3. 修改启动引导类Application中的Mapper扫描注解；\n4. 修改User实体类添加jpa注解；\n5. 改造UserService实现业务功能；\n\n**小结**：\n\n在启动引导类上面的mapper扫描注解一定要修改为通用mapper的扫描注解","tags":["Mapper"]},{"title":"SpringBoot整合-Mybatis","url":"/2020/04/03/SpringBoot整合-Mybatis/","content":"\n## SpringBoot整合-Mybatis\n\n**目标**：配置Mybatis在SpringBoot工程中的整合包，设置Mybatis的实体类别名，输出执行sql语句配置项\n\n**分析**：\n\n1. 添加启动器依赖；\n\n   ```xml\n   <dependency>\n   \t<groupId>org.mybatis.spring.boot</groupId>\n   \t<artifactId>mybatis-spring-boot-starter</artifactId>\n   \t<version>2.0.1</version>\n   </dependency>\n   ```\n\n   \n\n2. 配置Mybatis：实体类别名包，日志，映射文件等；\n\n   ```yml\n   mybatis:\n     # 实体类别名路径包\n     type-aliases-package: com.lin.demo.pojo\n     # 映射文件路径\n     mapper-locations: classpath:mappers/*.xml\n     configuration:\n       # 日志\n       log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n   ```\n\n   \n\n3. 配置MapperScan；\n\n   ![](MapperScan.png)\n\n\n\n","tags":["Mybatis"]},{"title":"Lombok插件的使用","url":"/2020/04/03/Lombok插件的使用/","content":"\n## Lombok应用\n\n目标：使用Lombok的注解实现pojo类的简化\n\n分析：\n\n使用SpringBoot整合SSM工程，需要使用到数据库数据。\n\n* 将数据库表数据导入到数据库中\n* 编写数据库对应的实体类；一般情况下需要编写get/set/toString等这些方法会耗时并且会让实体类看起来比较臃肿，可以使用lombok插件对实体类进行简化。\n\nLombok是一个插件工具类包；提供了一些注解@Data、@Getter等这些注解去简化实体类的构造方法、get/set等方法的编写。\n\n1. 在IDEA中安装lombok插件；\n\n   ![IDEA安装](安装.png)\n\n2. 添加lombok对应的依赖到羡慕pom.xml文件；\n\n   ```xml\n   <dependency>\n   \t<groupId>org.projectlombok</groupId>\n   \t<artifactId>lombok</artifactId>\n   </dependency>\n   ```\n\n   \n\n3. 改造实体类使用lombok注解；\n\n   ```\n   @Data\n   public class User {\n   \n       private int id;\n   \n       private String userName;\n   \n   }\n   ```\n\n   \n\n**小结**：\n\n在bean上使用：\n\n@Data：自动提供getter和setter、hashCode、equals、toString等方法\n\n@Getter：自动提供getter方法\n\n@Setter：自动提供setter方法\n\n@Slf4j：自动在bean中提供log变量，其实用的是slf4j的日志功能\n\n","tags":["lombok"]},{"title":"SpringBoot自动配置原理","url":"/2020/03/26/SpringBoot自动配置原理/","content":"\n## SpringBoot自动配置原理\n\n### @SpringBootApplication\n\n@SpringBootApplication：是SpringBoot项目的核心注解，目的是开启自动配置\n\n点开源码，可以看到：\n\n![](SpringBootApplication.png)\n\n我们从下往上开始分析：\n\n#### 1.@ComponentScan\n\n1）@ComponentScan：组件扫描，其功能是自动扫描并加载符合条件的组件（如@Component、@Controller、@Service、@Repository），最终将这些bean定义加载到IoC容器中。\n\n​\t我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认从声明@ComponentScan所在类的package进行扫描。\n\n2）参数的作用\n\n> basePackageClasses：对于basepackages() 指定扫描注释组件包类型安全的替代。\n>\n> excludeFilters：指定不适合组件扫描的类型。\n>\n> includeFilters：指定哪些类型有资格用于组件扫描。\n>\n> lazyInit：指定是否应注册扫描的beans为lazy初始化。\n>\n> nameGenerator：用于在Spring容器中的检测到的组件命名。\n>\n> resourcePattern：控制可用于组件检测的类文件。\n>\n> scopedProxy：指出代理是否应该对检测元件产生，在使用过程中会在代理风格时尚的范围是必要的。\n\n1. JavaConfig配置：\n\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.lin.demo.*\", useDefaultFilters = false, includeFilters = {\n        @Filter(type = FilterType.ANNOTATION, classes = Controller.class)\n})\npublic class JavaConfig {\n}\n```\n\nuseDefaultFilters = false 表示禁用默认的过滤规则\n\n2. FilterType类型\n   * ANNOTATION: 注解，常用\n   * ASSIGNABLE_TYPE: 给定类型，该类型及其子类、接口的实现类都起作用\n   * ASPECTJ: AspectJ表达式\n   * REGEX: 正则表达式\n   * CUSTOM: 自定义规则\n\n","tags":["SpringBoot","自动配置"]},{"title":"SpringBoot配置","url":"/2020/03/25/SpringBoot配置/","content":"\n##  SpringBoot学习之SpringBoot配置\n\n### 1.SpringBoot属性注入方式\n\n**目标**：能够使用@ConfigurationProperties实现SpringBoot配置文件配置项读取和应用\n\n**需求**：将配置文件中的配置项读取到一个对象中；\n\n**实现**：可以使用SpringBoot提供的注解@ConfigurationProperties，该注解可以将SpringBoot的配置文件（默认必须为application.properties或application.yml）中的配置项读取到一个对象中。\n\n实现步骤：\n\n1. 创建配置项类JdbcProperties类，在该类名上添加@ConfigurationProperties；\n2. 创建application.properties配置文件，并写入jdbc配置项；\n3. 将JdbcProperties对象注入到JdbcConfig；\n4. 测试\n\n**小结**：\n\n* 使用@ConfigurationProperties编写配置类将配置文件中的配置项设置到对象中\n\n  ```java\n  @ConfigurationProperties(prefix = \"jdbc\")\n  public class JdbcProperties {\n      private String url;\n      private String driverClassName;\n      private String username;\n      private String password;\n  \n      public String getUrl() {\n          return url;\n      }\n  \n      public void setUrl(String url) {\n          this.url = url;\n      }\n  \n      public String getDriverClassName() {\n          return driverClassName;\n      }\n  \n      public void setDriverClassName(String driverClassName) {\n          this.driverClassName = driverClassName;\n      }\n  \n      public String getUsername() {\n          return username;\n      }\n  \n      public void setUsername(String username) {\n          this.username = username;\n      }\n  \n      public String getPassword() {\n          return password;\n      }\n  \n      public void setPassword(String password) {\n          this.password = password;\n      }\n  }\n  ```\n\n* 使用@ConfigurationProperties在方法上使用\n\n  ```java\n  @Bean\n  @ConfigurationProperties(prefix = \"jdbc\")\n  public DataSource dataSource() {\n      return new DruidDataSource();\n  }\n  ```\n\n  \n\n### 2.yml文件配置\n\n**目标**：可以将多个yml文件在application.yml文件中配置激活\n\n**分析**：yaml与properties配置文件除了展示形式不相同以外，其他功能和作用都一样的；在项目中的原来的读取方式不需要改变。\n\nyml配置文件的特征：\n\n1. 树状层级结构展示配置项；\n2. 配置项之间如果有关系的话需要分两行空格；\n3. 配置项如果有值的话，那么需要在`:`之后空一格再写配置项值；\n\n1）将application.properties配置文件修改为application.yml的话；\n\n```yml\njdbc:\n\tdriverClassName: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/springboot_test\n\tusername: root\n\tpassword: root\n```\n\n2）多个yml配置文件在SpringBoot中是被允许的。这些配置文件的名称必须为application-***.yml，并且这些配置文件必须要在application.yml配置文件中激活之后才可以使用。\n\n```yml\nspring:\n\tprofiles: \n\t\tactive: abc     //abc即为application-abc.yml\n```\n\n3）如果properties和yml配置文件同时存在在SpringBoot项目中，那么这两类配置都有效。在两个配置文件中如果存在同名配置项的话会以properties文件的为主。","tags":["SpringBoot","SpringBoot配置"]},{"title":"SpringBoot学习","url":"/2020/03/25/SpringBoot学习/","content":"\n# SpringBoot 学习\n\n## 1.SpringBoot概述\n\n1. 关于SpringBoot\n\n   SpringBoot的设计目的是让项目尽可能快的启动和运行项目，而无需预先配置Spring。SpringBoot以一种固定的方式来构建可用于生产级别的应用程序。俗称：一个便捷搭建基于Spring工程的脚手架。\n\n2. 为什么要学习SpringBoot\n\n   解决Java复杂的配置和混乱的依赖管理。Springboot简化了基于Spring的应用开发。\n\n3. SpringBoot的特点\n\n   - 创建独立的Spring用用，为所有Spring的开发者提供一个非常快速的、广泛接受的入门体验。\n   - 直接嵌入应用服务器，如Tomcat、Jetty、Undertow等；不需要部署war包。\n   - 提供固定的启动器依赖去简化组件配置；实现开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），通过自己设置参数（.properties或.yml的配置文件），即可快速使用。\n   - 自动地配置Spring和其他有需要的第三方依赖。\n   - 提供了一些大型项目中常见的非功能性特效，如内嵌服务器、安全、指标、健康检测、外部化配置等。\n   - 绝对没有代码生成，也无需XML配置。\n\n## 2.SpringBoot入门\n\n1. 在pom.xml中添加基本依赖\n\n   ```xml\n   <!-- 副工程依赖 -->\n   <parent>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-parent</artifactId>\n           <version>2.1.5.RELEASE</version>\n   </parent>\n   \n   <dependencies>\n   \t\t<!-- SpringBoot的依赖 -->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-web</artifactId>\n           </dependency>\n           <!-- JSON依赖-->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-json</artifactId>\n           </dependency>\n           <!-- Tomcat依赖-->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-tomcat</artifactId>\n           </dependency>\n           <!-- Hibernate Validator依赖-->\n           <dependency>\n               <groupId>org.hibernate.validator</groupId>\n               <artifactId>hibernate-validator</artifactId>\n           </dependency>\n           <!-- Spring Web依赖-->\n           <dependency>\n               <groupId>org.springframework</groupId>\n               <artifactId>spring-web</artifactId>\n               <version>5.1.7.RELEASE</version>\n           </dependency>\n           <!-- Spring Web MVC依赖-->\n           <dependency>\n               <groupId>org.springframework</groupId>\n               <artifactId>spring-webmvc</artifactId>\n               <version>5.1.7.RELEASE</version>\n           </dependency>\n   </dependencies>\n   ```\n\n   \n\n2. 通过注解@Component&@ComponentScan扫描装配 Bean\n\n   User.java:\n\n   ```java\n   package com.lin.demo;\n   \n   \n   import org.springframework.beans.factory.annotation.Value;\n   import org.springframework.stereotype.Component;\n   \n   //若不配置名称，默认为类开头小写\n   @Component(\"user\")\n   public class User {\n       @Value(\"1\")\n       private int id;\n       @Value(\"user_name_1\")\n       private String userName;\n       @Value(\"note1\")\n       private String note;\n       \n       /**  setter and getter  **/\n   }\n   ```\n\n   为了让Spring IoC 容器装配这个类，需要改造类AppConfig\n\n   AppConfig.java\n\n   ```java\n   package com.lin.demo;\n   \n   \n   import org.springframework.context.annotation.ComponentScan;\n   import org.springframework.context.annotation.Configuration;\n   \n   @Configuration\n   @ComponentScan\n   public class AppConfig {\n   }\n   ```\n\n3. 测试扫描\n\n   ```java\n   ApplicationContext ctx\n   \t= new AnnotationConfigApplicationContext(AppConfig.class);\n   User user = ctx.getBean(User.class);\n   ```\n\n## Java配置\n\n常用注解：\n\n* @Configuration：声明一个类作为配置类，代替xml文件\n* @Bean：声明在方法上，将方法的返回值加入Bean容器，代替<bean>标签\n* @Value：属性注入\n* @propertySource：指定外部属性文件","tags":["SpringBoot"]}]